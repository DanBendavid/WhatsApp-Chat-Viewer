<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WhatsApp Chat Viewer</title>
  <style>
    /* Mimic WhatsApp background */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f0f2f5;
      margin: 0;
      padding: 0;
    }
    :root {
      --image-size: 120px;
    }
    h2 {
      background-color: #0084ff;
      color: white;
      margin: 0;
      padding: 10px;
      text-align: center;
    }
    /* Layout */
    #app {
      max-width: 1200px;
      margin: 20px auto;
      display: grid;
      grid-template-columns: 110px 1fr;
      gap: 14px;
      padding: 0 10px;
    }
    #timeline {
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
      padding: 10px 8px;
      height: 80vh;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
      position: relative;
      z-index: 1;
    }
    #timeline-title {
      font-size: 12px;
      color: #444;
      text-align: center;
      margin-bottom: 6px;
    }
    .timeline-filter {
      font-size: 11px;
      text-align: center;
      color: #0084ff;
      cursor: pointer;
      padding: 4px 0;
      border-radius: 4px;
    }
    .timeline-filter.active {
      background: #e3f2fd;
      font-weight: 600;
    }
    #timeline-bars {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
      overflow: auto;
    }
    .timeline-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .timeline-bar {
      height: 12px;
      border-radius: 4px;
      background: #cfd8dc;
      position: relative;
      cursor: pointer;
      flex: 1;
    }
    .timeline-bar span {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      border-radius: 4px;
      background: #42a5f5;
    }
    .timeline-bar.active {
      outline: 2px solid #0084ff;
    }
    .timeline-label {
      font-size: 10px;
      color: #666;
      text-transform: capitalize;
      letter-spacing: 0.2px;
      margin-top: 6px;
      cursor: pointer;
    }
    .timeline-label.active {
      color: #0084ff;
      font-weight: 600;
    }

    /* Chat container styling */
    #chat-container {
      padding: 10px;
      background-color: #ffffff;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
      overflow-y: auto;
      height: 80vh;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    #chat-container.hide-images img {
      display: none;
    }
    #chat-container.hide-images video {
      display: none;
    }
    #chat-container.hide-images .media-images-only {
      display: none;
    }
    #chat-container.hide-images .media-videos-only {
      display: none;
    }
    /* Chat bubble styling */
    .message {
      margin: 0;
      padding: 8px 12px;
      border-radius: 7px;
      max-width: 72%;
      word-wrap: break-word;
      clear: both;
    }
    .message.media-only {
      padding-top: 6px;
    }
    .message.media-only .media {
      margin-top: 0;
    }
    .message-row {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      margin: 5px 0;
    }
    .message-row .message {
      display: inline-block;
    }
    .message-row.user {
      justify-content: flex-end;
    }
    .message-row.user .message {
      order: 1;
    }
    .message-row.user .initials {
      order: 2;
    }
    .message-row.other {
      justify-content: flex-start;
    }
    .message-row.other .initials {
      order: 1;
    }
    .message-row.other .message {
      order: 2;
    }
    .initials {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      flex-shrink: 0;
    }
    .message-row.media-only .initials {
    }
    .message-row.other .initials {
      background: #1976d2;
      color: #ffffff;
    }
    .message-row.user .initials {
      background: #0084ff;
      color: #ffffff;
    }
    .message.user {
      background-color: #e3f2fd;
      text-align: right;
    }
    .message.other {
      background-color: #ffffff;
      border: 1px solid #e9edef;
      text-align: left;
    }
    .time-group {
      padding: 6px 8px;
      border-radius: 6px;
      margin-top: 6px;
    }
    .time-group.day {
      background: #f7f8fa;
    }
    .time-group.night {
      background: #f0f2f5;
    }
    .time-header {
      font-size: 12px;
      color: #555;
      text-align: center;
      margin: 2px 0 6px;
      text-transform: capitalize;
    }
    img, video {
      max-width: 100%;
      margin-top: 5px;
      border-radius: 5px;
    }
    .media {
      margin-left: 20px;
      margin-top: 6px;
      opacity: 0.95;
    }
    .media img,
    .media video {
      margin-top: 0;
    }
    .media img {
      width: 100%;
      max-width: var(--image-size);
    }
    .image-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      margin-top: 6px;
    }
    .image-grid img {
      width: 100%;
      height: auto;
      display: block;
    }
    .message-text {
      margin-top: 0;
      white-space: pre-wrap;
    }
    a.download-link {
      margin-top: 5px;
      display: block;
    }
    /* File input styling */
    #fileInput {
      margin: 10px auto;
      display: block;
    }
    #media-controls {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin: 6px auto 12px;
      flex-wrap: wrap;
    }
    .control-button {
      border: 1px solid #d1d7db;
      background: #ffffff;
      color: #0084ff;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }
    .control-button.active {
      background: #0084ff;
      color: #ffffff;
      border-color: #0084ff;
    }
    #image-size-control {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #555;
      border: 1px solid #cfd8dc;
      background: #ffffff;
      padding: 6px 10px;
      border-radius: 6px;
    }
    #image-size {
      width: 140px;
    }
    #user-selector {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #555;
      border: 1px solid #cfd8dc;
      background: #ffffff;
      padding: 6px 10px;
      border-radius: 6px;
    }
    #user-select {
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #cfd8dc;
      background: #ffffff;
      font-size: 12px;
    }
    #load-controls {
      display: none;
      justify-content: center;
      gap: 8px;
      align-items: center;
      margin: 0 auto 12px;
      flex-wrap: wrap;
      font-size: 12px;
      color: #666;
    }
    #load-hint {
      max-width: 640px;
      text-align: center;
    }
    #print-header,
    #print-footer {
      display: none;
    }
    @media print {
      :root {
        --print-header-height: 14mm;
        --print-footer-height: 12mm;
      }
      body {
        background: #ffffff;
        padding: 0;
      }
      h2,
      #media-controls,
      #load-controls,
      #fileInput {
        display: none !important;
      }
      #app {
        max-width: none;
        margin: 0;
        padding: 0;
        grid-template-columns: 1fr;
      }
      #timeline {
        display: none !important;
      }
      #print-header,
      #print-footer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        position: fixed;
        left: 0;
        right: 0;
        height: var(--print-header-height);
        padding: 0 12mm;
        font-size: 11px;
        color: #444;
        background: #ffffff;
      }
      #print-header {
        top: 0;
        border-bottom: 1px solid #d1d7db;
      }
      #print-footer {
        bottom: 0;
        height: var(--print-footer-height);
        border-top: 1px solid #d1d7db;
      }

      #chat-container {
        height: auto !important;
        overflow: visible !important;
        box-shadow: none;
        border-radius: 0;
      }
      .message {
        max-width: 100%;
      }
      .time-group,
      .message-row,
      .message,
      .message-text {
        break-inside: avoid;
        page-break-inside: avoid;
      }
      .time-header {
        break-after: avoid;
        page-break-after: avoid;
      }
      .message-text {
        orphans: 3;
        widows: 3;
      }
      @page {
        margin: 18mm 12mm 16mm;
      }
    }
  </style>
</head>
<body>
  <h2>WhatsApp Chat Viewer</h2>
  <div id="print-header" aria-hidden="true">
    <span id="print-title">WhatsApp Chat Viewer</span>
  </div>
  <input type="file" id="fileInput" accept=".txt">
  <div id="media-controls">
    <button id="show-images" class="control-button active" type="button">Afficher images</button>
    <button id="hide-images" class="control-button" type="button">Masquer images</button>
    <label id="image-size-control" for="image-size">
      <span>Largeur images</span>
      <input id="image-size" type="range" min="80" max="480" step="10" value="120">
      <span id="image-size-value">120px</span>
    </label>
    <label id="user-selector" for="user-select">
      <span>Utilisateur (à droite):</span>
      <select id="user-select">
        <option value="">Chargez un fichier...</option>
      </select>
    </label>
  </div>
  <div id="load-controls">
    <button id="pick-chat" class="control-button" type="button">Choisir _chat.txt</button>
    <span id="load-hint">Le navigateur bloque souvent l'accès automatique aux fichiers locaux. Lancez un serveur local (ex: Live Server) ou choisissez le fichier une fois.</span>
  </div>
  <div id="app">
    <div id="timeline">
      <div id="timeline-title">Frise</div>
      <div id="timeline-bars"></div>
    </div>
    <div id="chat-container"></div>
  </div>
  <div id="print-footer" aria-hidden="true">
    <span id="print-pages"></span>
  </div>
  
  <script>
    // Global variables for infinite scroll loading
    let allMessages = [];
    let renderItems = [];
    let currentIndex = 0;
    const chunkSize = 100;
    const chatContainer = document.getElementById("chat-container");
    const timelineBars = document.getElementById("timeline-bars");
    const timelineTitle = document.getElementById("timeline-title");
    const showImagesButton = document.getElementById("show-images");
    const hideImagesButton = document.getElementById("hide-images");
    const imageSizeInput = document.getElementById("image-size");
    const imageSizeValue = document.getElementById("image-size-value");
    const userSelect = document.getElementById("user-select");
    const fileInput = document.getElementById("fileInput");
    const loadControls = document.getElementById("load-controls");
    const pickChatButton = document.getElementById("pick-chat");
    const printTitle = document.getElementById("print-title");
    if (fileInput) {
      fileInput.style.display = "none";
    }
    if (loadControls) {
      loadControls.style.display = "none";
    }
    if (printTitle) {
      const heading = document.querySelector("h2");
      printTitle.textContent = heading ? heading.textContent : document.title;
    }

    let activeDayKey = null; // null = all
    let activeMonthKey = null; // "YYYY-MM"
    let activeYearKey = null; // "YYYY"
    let lastGroupElement = null;
    let selectedUser = null; // The user whose messages appear on the right
    let dateOrder = "DMY"; // "DMY" or "MDY"

    const IMAGE_EXTS = ["jpg", "png", "jpeg", "gif", "webp"];
    const VIDEO_EXTS = ["mp4", "webm", "ogg"];

    const PERIODS = [
      { name: "nuit", start: 22, end: 24, theme: "night" },
      { name: "nuit", start: 0, end: 5, theme: "night" },
      { name: "matin", start: 5, end: 12, theme: "day" },
      { name: "après-midi", start: 12, end: 17, theme: "day" },
      { name: "soir", start: 17, end: 22, theme: "night" }
    ];

    function parseTime(timeStr) {
      const trimmed = timeStr.trim();
      const ampmMatch = trimmed.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(AM|PM)$/i);
      if (ampmMatch) {
        let hour = Number(ampmMatch[1]);
        const minute = Number(ampmMatch[2]);
        const second = Number(ampmMatch[3] || 0);
        const meridiem = ampmMatch[4].toUpperCase();
        if (meridiem === "PM" && hour < 12) hour += 12;
        if (meridiem === "AM" && hour === 12) hour = 0;
        return { hour, minute, second };
      }
      const [hh, min, ss] = trimmed.split(":").map(Number);
      return { hour: hh, minute: min, second: ss || 0 };
    }

    function parseDate(dateStr, timeStr) {
      const [partA, partB, partC] = dateStr.split("/").map(Number);
      let year = partC;
      if (year < 100) {
        year = year >= 70 ? 1900 + year : 2000 + year;
      }
      let day = partA;
      let month = partB;
      if (dateOrder === "MDY") {
        day = partB;
        month = partA;
      }
      if (month < 1 || month > 12) {
        day = partA;
        month = partB;
      }
      const { hour, minute, second } = parseTime(timeStr);
      return new Date(year, month - 1, day, hour, minute, second);
    }

    function detectDateOrder(messages, preferMDY) {
      let dmyHits = 0;
      let mdyHits = 0;
      messages.forEach(msg => {
        const [partA, partB] = msg.date.split("/").map(Number);
        if (Number.isNaN(partA) || Number.isNaN(partB)) return;
        if (partA > 12 && partB <= 12) {
          dmyHits += 1;
        } else if (partB > 12 && partA <= 12) {
          mdyHits += 1;
        }
      });
      if (mdyHits > dmyHits) return "MDY";
      if (dmyHits > mdyHits) return "DMY";
      return preferMDY ? "MDY" : "DMY";
    }

    function getPeriod(dateObj) {
      const hour = dateObj.getHours();
      for (const p of PERIODS) {
        if (hour >= p.start && hour < p.end) {
          return p;
        }
      }
      return PERIODS[2];
    }

    function formatDateFr(dateObj) {
      return dateObj.toLocaleDateString("fr-FR", {
        weekday: "long",
        day: "numeric",
        month: "long",
        year: "numeric"
      });
    }
    function parseMessageContent(message) {
      const cleanedMessage = message.replace(/\u200E/g, "").trim();
      const attachmentRegex = /<\s*pi(?:e|\u00e8|\u00c3\u00a8)ce jointe\s*:\s*([^>]+)\s*>/ig;
      const fileAttachedText = "(file attached)";
      let fileNames = [];
      let textOnly = cleanedMessage;

      const attachmentMatches = [...cleanedMessage.matchAll(attachmentRegex)];
      if (attachmentMatches.length > 0) {
        fileNames = attachmentMatches.map(match => match[1].trim()).filter(Boolean);
        attachmentRegex.lastIndex = 0;
        textOnly = cleanedMessage.replace(attachmentRegex, "").trim();
      } else if (cleanedMessage.includes(fileAttachedText)) {
        const inferred = cleanedMessage.replace(fileAttachedText, "").trim();
        if (inferred) {
          fileNames = [inferred];
        }
        textOnly = "";
      }

      return { textOnly, fileNames };
    }

    function isImageFile(name) {
      const ext = name.split('.').pop().toLowerCase();
      return IMAGE_EXTS.includes(ext);
    }
    function isVideoFile(name) {
      const ext = name.split('.').pop().toLowerCase();
      return VIDEO_EXTS.includes(ext);
    }

    function getInitials(name) {
      const cleaned = (name || "").trim();
      if (!cleaned) return "?";
      const parts = cleaned.split(/\s+/).filter(Boolean);
      const first = parts[0]?.charAt(0) || "";
      const last = parts.length > 1 ? parts[parts.length - 1].charAt(0) : "";
      return (first + last).toUpperCase();
    }
    function mergeImageSequences(messages) {
      const merged = [];
      for (let i = 0; i < messages.length; i++) {
        const msg = messages[i];
        const { textOnly, fileNames } = parseMessageContent(msg.message);
        const isImageOnly = textOnly === "" && fileNames.length > 0 && fileNames.every(isImageFile);
        if (!isImageOnly) {
          merged.push(msg);
          continue;
        }

        const groupedFileNames = [...fileNames];
        let j = i + 1;
        for (; j < messages.length; j++) {
          const next = messages[j];
          if (next.sender !== msg.sender) break;
          const nextContent = parseMessageContent(next.message);
          const nextIsImageOnly = nextContent.textOnly === "" && nextContent.fileNames.length > 0 && nextContent.fileNames.every(isImageFile);
          if (!nextIsImageOnly) break;
          groupedFileNames.push(...nextContent.fileNames);
        }

        const groupedMessage = groupedFileNames.map(name => `< piece jointe : ${name} >`).join(" ");
        merged.push({ ...msg, message: groupedMessage });
        i = j - 1;
      }
      return merged;
    }

    function setImagesVisible(visible) {
      chatContainer.classList.toggle("hide-images", !visible);
      showImagesButton.classList.toggle("active", visible);
      hideImagesButton.classList.toggle("active", !visible);
    }

    showImagesButton.addEventListener("click", () => setImagesVisible(true));
    hideImagesButton.addEventListener("click", () => setImagesVisible(false));
    
    function setImageSize(value) {
      const pxValue = `${value}px`;
      document.documentElement.style.setProperty("--image-size", pxValue);
      imageSizeValue.textContent = pxValue;
    }
    setImageSize(imageSizeInput.value);
    imageSizeInput.addEventListener("input", (event) => setImageSize(event.target.value));

    // User selection handler
    userSelect.addEventListener("change", (event) => {
      selectedUser = event.target.value;
      // Re-render with new user selection
      if (activeDayKey) {
        renderFromFilter(activeDayKey);
      } else if (activeMonthKey) {
        renderFromMonth(activeMonthKey);
      } else if (activeYearKey) {
        renderFromYear(activeYearKey);
      } else {
        renderFromFilter(null);
      }
    });

    // Function to create a chat bubble element
    function createMessageElement(date, time, sender, message, isUser) {
      const row = document.createElement("div");
      row.classList.add("message-row", isUser ? "user" : "other");

      const initials = document.createElement("div");
      initials.classList.add("initials");
      initials.textContent = getInitials(sender);
      
      let msgElement = document.createElement("div");
      msgElement.classList.add("message", isUser ? "user" : "other");

      const { textOnly, fileNames } = parseMessageContent(message);

      const hasText = Boolean(textOnly);
      const hasMedia = fileNames.length > 0;
      const isMediaOnly = !hasText && hasMedia;
      if (isMediaOnly) {
        row.classList.add("media-only");
        msgElement.classList.add("media-only");
      }

      if (hasText) {
        const textEl = document.createElement("div");
        textEl.classList.add("message-text");
        textEl.textContent = textOnly;
        msgElement.appendChild(textEl);
      }

      if (hasMedia) {
        const mediaWrap = document.createElement("div");
        mediaWrap.classList.add("media");

        const allImages = fileNames.every(isImageFile);
        const allVideos = fileNames.every(isVideoFile);
        if (allImages) {
          mediaWrap.classList.add("media-images-only");
        }
        if (allVideos) {
          mediaWrap.classList.add("media-videos-only");
        }

        if (fileNames.length > 1 && allImages) {
          const grid = document.createElement("div");
          grid.classList.add("image-grid");
          fileNames.forEach(name => {
            const img = document.createElement("img");
            img.src = encodeURI(name);
            grid.appendChild(img);
          });
          mediaWrap.appendChild(grid);
        } else {
          fileNames.forEach(name => {
            const fileExt = name.split('.').pop().toLowerCase();
            let mediaElement;
            const fileUrl = encodeURI(name);
            if (IMAGE_EXTS.includes(fileExt)) {
              mediaElement = document.createElement("img");
              mediaElement.src = fileUrl;
            } else if (VIDEO_EXTS.includes(fileExt)) {
              mediaElement = document.createElement("video");
              mediaElement.src = fileUrl;
              mediaElement.controls = true;
            } else {
              mediaElement = document.createElement("a");
              mediaElement.href = fileUrl;
              mediaElement.innerText = "Download File";
              mediaElement.classList.add("download-link");
              mediaElement.target = "_blank";
            }
            mediaWrap.appendChild(mediaElement);
          });
        }
        msgElement.appendChild(mediaWrap);
      }
      
      // Append in correct order for grid
      row.appendChild(initials);
      row.appendChild(msgElement);
      
      return row;
    }

    function createHeaderElement(dateObj, period) {
      const group = document.createElement("div");
      group.classList.add("time-group", period.theme);
      const header = document.createElement("div");
      header.classList.add("time-header");
      header.textContent = `${formatDateFr(dateObj)} — ${period.name}`;
      group.appendChild(header);
      return group;
    }

    function buildRenderItems(messages) {
      const items = [];
      let lastKey = "";
      
      messages.forEach(msg => {
        const dateObj = parseDate(msg.date, msg.time);
        const period = getPeriod(dateObj);
        const dayKey = dateObj.toISOString().slice(0, 10);
        
        // Determine if this message is from the selected user
        const isUser = selectedUser ? (msg.sender === selectedUser) : false;
        
        const key = `${dayKey}-${period.name}`;
        if (key !== lastKey) {
          items.push({
            type: "header",
            dateObj,
            period
          });
          lastKey = key;
        }
        items.push({
          type: "message",
          data: msg,
          isUser
        });
      });
      return items;
    }

    function renderFromFilter(dayKey) {
      activeDayKey = dayKey;
      activeMonthKey = null;
      activeYearKey = null;
      const filteredRaw = dayKey
        ? allMessages.filter(m => parseDate(m.date, m.time).toISOString().slice(0, 10) === dayKey)
        : allMessages.slice();
      const filtered = mergeImageSequences(filteredRaw);
      renderItems = buildRenderItems(filtered);
      chatContainer.innerHTML = "";
      currentIndex = 0;
      lastGroupElement = null;
      loadNextMessages();
      updateTimelineActive();
    }

    function renderFromMonth(monthKey) {
      activeDayKey = null;
      activeMonthKey = monthKey;
      activeYearKey = null;
      const filteredRaw = allMessages.filter(m => {
        const key = parseDate(m.date, m.time).toISOString().slice(0, 7);
        return key === monthKey;
      });
      const filtered = mergeImageSequences(filteredRaw);
      renderItems = buildRenderItems(filtered);
      chatContainer.innerHTML = "";
      currentIndex = 0;
      lastGroupElement = null;
      loadNextMessages();
      updateTimelineActive();
    }

    function renderFromYear(yearKey) {
      activeDayKey = null;
      activeMonthKey = null;
      activeYearKey = yearKey;
      const filteredRaw = allMessages.filter(m => {
        const key = parseDate(m.date, m.time).getFullYear().toString();
        return key === yearKey;
      });
      const filtered = mergeImageSequences(filteredRaw);
      renderItems = buildRenderItems(filtered);
      chatContainer.innerHTML = "";
      currentIndex = 0;
      lastGroupElement = null;
      loadNextMessages();
      updateTimelineActive();
    }

    function updateTimelineActive() {
      const bars = timelineBars.querySelectorAll(".timeline-bar");
      bars.forEach(bar => {
        const key = bar.getAttribute("data-day");
        bar.classList.toggle("active", key === activeDayKey);
      });
      const labels = timelineBars.querySelectorAll(".timeline-label");
      labels.forEach(label => {
        const monthKey = label.getAttribute("data-month");
        const yearKey = label.getAttribute("data-year");
        label.classList.toggle("active", monthKey === activeMonthKey || yearKey === activeYearKey);
      });
      const allFilter = document.getElementById("timeline-all");
      if (allFilter) {
        allFilter.classList.toggle("active", activeDayKey === null && activeMonthKey === null && activeYearKey === null);
      }
    }

    function buildTimeline(messages) {
      timelineBars.innerHTML = "";
      const counts = new Map();
      messages.forEach(msg => {
        const dateObj = parseDate(msg.date, msg.time);
        const dayKey = dateObj.toISOString().slice(0, 10);
        counts.set(dayKey, (counts.get(dayKey) || 0) + 1);
      });
      const entries = Array.from(counts.entries()).sort((a, b) => a[0].localeCompare(b[0]));
      const maxCount = Math.max(1, ...entries.map(e => e[1]));

      // Add "All" filter
      const allFilter = document.createElement("div");
      allFilter.id = "timeline-all";
      allFilter.classList.add("timeline-filter");
      allFilter.textContent = "Toute la période";
      allFilter.addEventListener("click", () => renderFromFilter(null));
      timelineBars.appendChild(allFilter);

      let lastMonthKey = "";
      let lastYearKey = "";
      entries.forEach(([dayKey, count]) => {
        const [year, month] = dayKey.split("-");
        const monthKey = `${year}-${month}`;
        if (year !== lastYearKey) {
          const yearLabel = document.createElement("div");
          yearLabel.classList.add("timeline-label");
          yearLabel.textContent = year;
          yearLabel.setAttribute("data-year", year);
          timelineBars.appendChild(yearLabel);
          lastYearKey = year;
          lastMonthKey = "";
        }
        if (monthKey !== lastMonthKey) {
          const dateObj = new Date(Number(year), Number(month) - 1, 1);
          const monthLabel = document.createElement("div");
          monthLabel.classList.add("timeline-label");
          monthLabel.textContent = dateObj.toLocaleDateString("fr-FR", { month: "long" });
          monthLabel.setAttribute("data-month", monthKey);
          timelineBars.appendChild(monthLabel);
          lastMonthKey = monthKey;
        }
        const row = document.createElement("div");
        row.classList.add("timeline-row");
        const bar = document.createElement("div");
        bar.classList.add("timeline-bar");
        bar.setAttribute("data-day", dayKey);
        const fill = document.createElement("span");
        const ratio = count / maxCount;
        const scaledRatio = Math.sqrt(ratio);
        const widthPercent = Math.max(12, Math.round(scaledRatio * 100));
        fill.style.width = `${widthPercent}%`;
        fill.style.background = `rgba(76, 175, 80, ${0.35 + scaledRatio * 0.65})`;
        bar.title = `${dayKey} — ${count} messages`;
        bar.appendChild(fill);
        bar.addEventListener("click", () => renderFromFilter(dayKey));
        row.appendChild(bar);
        timelineBars.appendChild(row);
      });
      updateTimelineActive();
    }

    // Event delegation for reliability
    timelineBars.addEventListener("click", (event) => {
      const bar = event.target.closest(".timeline-bar");
      if (bar && bar.getAttribute("data-day")) {
        renderFromFilter(bar.getAttribute("data-day"));
        return;
      }
      const monthLabel = event.target.closest(".timeline-label[data-month]");
      if (monthLabel) {
        renderFromMonth(monthLabel.getAttribute("data-month"));
        return;
      }
      const yearLabel = event.target.closest(".timeline-label[data-year]");
      if (yearLabel) {
        renderFromYear(yearLabel.getAttribute("data-year"));
        return;
      }
      const allFilter = event.target.closest("#timeline-all");
      if (allFilter) {
        renderFromFilter(null);
      }
    });

    // Function to load the next batch of messages
    function loadNextMessages() {
      let endIndex = Math.min(currentIndex + chunkSize, renderItems.length);
      let currentGroup = lastGroupElement;
      for (let i = currentIndex; i < endIndex; i++) {
        const item = renderItems[i];
        if (item.type === "header") {
          currentGroup = createHeaderElement(item.dateObj, item.period);
          chatContainer.appendChild(currentGroup);
          lastGroupElement = currentGroup;
        } else {
          const { date, time, sender, message } = item.data;
          const msgElement = createMessageElement(date, time, sender, message, item.isUser);
          if (currentGroup) {
            currentGroup.appendChild(msgElement);
          } else {
            chatContainer.appendChild(msgElement);
          }
        }
      }
      currentIndex = endIndex;
    }

    function loadAllMessagesForPrint() {
      if (!renderItems.length) return;
      while (currentIndex < renderItems.length) {
        loadNextMessages();
      }
    }

    // Event listener for infinite scroll: load more messages when near the bottom
    chatContainer.addEventListener("scroll", function() {
      if (chatContainer.scrollTop + chatContainer.clientHeight >= chatContainer.scrollHeight - 50) {
        if (currentIndex < allMessages.length) {
          loadNextMessages();
        }
      }
    });

    window.addEventListener("beforeprint", loadAllMessagesForPrint);
    const printMedia = window.matchMedia ? window.matchMedia("print") : null;
    if (printMedia && typeof printMedia.addEventListener === "function") {
      printMedia.addEventListener("change", (event) => {
        if (event.matches) {
          loadAllMessagesForPrint();
        }
      });
    } else if (printMedia && typeof printMedia.addListener === "function") {
      printMedia.addListener((event) => {
        if (event.matches) {
          loadAllMessagesForPrint();
        }
      });
    }

    // Populate user selector dropdown
    function populateUserSelector(messages) {
      const senders = new Set();
      messages.forEach(msg => senders.add(msg.sender));
      
      userSelect.innerHTML = "";
      
      // Add default option
      const defaultOption = document.createElement("option");
      defaultOption.value = "";
      defaultOption.textContent = "Sélectionner l'utilisateur...";
      userSelect.appendChild(defaultOption);
      
      // Add sender options
      Array.from(senders).sort().forEach(sender => {
        const option = document.createElement("option");
        option.value = sender;
        option.textContent = sender;
        userSelect.appendChild(option);
      });
      
      // Auto-select second sender if there are exactly 2 senders
      const sendersArray = Array.from(senders).sort();
      if (sendersArray.length === 2) {
        selectedUser = sendersArray[1];
        userSelect.value = selectedUser;
      }
    }

    function loadChatFromText(rawText) {
      // Reset chat container and global message variables
      chatContainer.innerHTML = "";
      allMessages = [];
      renderItems = [];
      currentIndex = 0;
      activeDayKey = null;
      activeMonthKey = null;
      activeYearKey = null;
      lastGroupElement = null;
      selectedUser = null;

      // Regex to match:
      // - [DD/MM/YYYY HH:MM:SS] Sender: Message
      // - [MM/DD/YY, H:MM:SS AM] Sender: Message
      const lineRegexClassic = /^\[(\d{2}\/\d{2}\/\d{4})\s+(\d{2}:\d{2}:\d{2})\]\s*(.*?):\s*(.*)$/;
      const lineRegexEnglish = /^\[(\d{1,2}\/\d{1,2}\/\d{2,4}),\s+(\d{1,2}:\d{2}(?::\d{2})?\s*(?:AM|PM))\]\s*-?\s*(.*?):\s*(.*)$/i;
      const lines = rawText.split(/\r?\n/);

      let current = null;
      let preferMDY = false;
      lines.forEach(rawLine => {
        const line = rawLine.replace(/\u200E/g, "").replace(/^\uFEFF/, "");
        let match = line.match(lineRegexClassic);
        let isEnglish = false;
        if (!match) {
          match = line.match(lineRegexEnglish);
          isEnglish = Boolean(match);
        }
        if (match) {
          if (current) {
            allMessages.push(current);
          }
          const [_, date, time, sender, message] = match;
          if (isEnglish) {
            preferMDY = true;
          }
          current = { date, time, sender, message };
        } else if (current) {
          current.message += "\n" + line;
        }
      });
      if (current) {
        allMessages.push(current);
      }

      dateOrder = detectDateOrder(allMessages, preferMDY);
      populateUserSelector(allMessages);
      buildTimeline(allMessages);
      renderFromFilter(null);
      if (loadControls) {
        loadControls.style.display = "none";
      }
      if (fileInput) {
        fileInput.style.display = "none";
      }
    }

    function supportsFileAccess() {
      return typeof window.showOpenFilePicker === "function" && !!window.indexedDB;
    }

    function openHandleDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open("whatsapp-viewer", 1);
        request.onupgradeneeded = () => {
          request.result.createObjectStore("handles");
        };
        request.onsuccess = () => resolve(request.result);
        request.onerror = () => reject(request.error);
      });
    }

    function txDone(tx) {
      return new Promise((resolve, reject) => {
        tx.oncomplete = () => resolve();
        tx.onerror = () => reject(tx.error);
        tx.onabort = () => reject(tx.error);
      });
    }

    async function getStoredHandle() {
      const db = await openHandleDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction("handles", "readonly");
        const store = tx.objectStore("handles");
        const request = store.get("chatFile");
        request.onsuccess = () => resolve(request.result || null);
        request.onerror = () => reject(request.error);
      });
    }

    async function storeHandle(handle) {
      const db = await openHandleDB();
      const tx = db.transaction("handles", "readwrite");
      tx.objectStore("handles").put(handle, "chatFile");
      await txDone(tx);
    }

    async function tryLoadStoredHandle() {
      if (!supportsFileAccess()) return false;
      let handle = null;
      try {
        handle = await getStoredHandle();
      } catch (error) {
        console.warn("Stored handle read failed:", error);
        return false;
      }
      if (!handle) return false;
      try {
        const perm = handle.queryPermission ? await handle.queryPermission({ mode: "read" }) : "granted";
        if (perm !== "granted") return false;
        const file = await handle.getFile();
        const text = await file.text();
        if (!text.trim()) return false;
        loadChatFromText(text);
        return true;
      } catch (error) {
        console.warn("Stored handle load failed:", error);
        return false;
      }
    }

    function showLoadFailure(error) {
      console.error("Auto-load _chat.txt failed:", error);
      chatContainer.innerHTML =
        "<p style=\"padding:12px;color:#666;\">Impossible de charger automatiquement <strong>_chat.txt</strong>. " +
        "Ouvrez ce fichier via un serveur local (ex: Live Server) ou choisissez le fichier ci-dessous.</p>";
      if (loadControls) {
        loadControls.style.display = "flex";
      }
      if (fileInput && !supportsFileAccess()) {
        fileInput.style.display = "block";
      }
    }

    async function chooseChatFile() {
      if (supportsFileAccess()) {
        try {
          const [handle] = await window.showOpenFilePicker({
            multiple: false,
            types: [
              {
                description: "Fichiers texte",
                accept: { "text/plain": [".txt"] }
              }
            ]
          });
          if (!handle) return;
          const file = await handle.getFile();
          const text = await file.text();
          if (!text.trim()) {
            throw new Error("Empty file");
          }
          loadChatFromText(text);
          try {
            await storeHandle(handle);
          } catch (error) {
            console.warn("Store handle failed:", error);
          }
        } catch (error) {
          console.error("Manual pick failed:", error);
        }
        return;
      }
      if (fileInput) {
        fileInput.click();
      }
    }

    async function autoLoadChatFile() {
      const chatUrl = new URL("_chat.txt", window.location.href);
      try {
        const response = await fetch(chatUrl.toString(), { cache: "no-store" });
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        const text = await response.text();
        if (!text.trim()) {
          throw new Error("Empty file");
        }
        loadChatFromText(text);
      } catch (error) {
        const loadedFromHandle = await tryLoadStoredHandle();
        if (loadedFromHandle) return;
        showLoadFailure(error);
      }
    }

    // File input event: parse file and prepare messages for infinite scroll
    if (fileInput) {
      fileInput.addEventListener("change", function(event) {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
          loadChatFromText(e.target.result || "");
        };
        reader.readAsText(file, "UTF-8");
      });
    }

    if (pickChatButton) {
      pickChatButton.addEventListener("click", function() {
        chooseChatFile();
      });
    }

    // Auto-load _chat.txt from the same folder
    autoLoadChatFile();
  </script>
</body>
</html>
