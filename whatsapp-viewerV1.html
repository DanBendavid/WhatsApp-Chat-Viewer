<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WhatsApp Chat Viewer</title>
  <style>
    /* Mimic WhatsApp background */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f0f2f5;
      margin: 0;
      padding: 0;
    }
    :root {
      --image-size: 120px;
    }
    h2 {
      background-color: #0084ff;
      color: white;
      margin: 0;
      padding: 10px;
      text-align: center;
    }
    /* Layout */
    #app {
      max-width: 1200px;
      margin: 20px auto;
      display: grid;
      grid-template-columns: 110px 1fr;
      gap: 14px;
      padding: 0 10px;
    }
    #timeline {
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
      padding: 10px 8px;
      height: 80vh;
      overflow: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
      position: relative;
      z-index: 1;
    }
    #timeline-title {
      font-size: 12px;
      color: #444;
      text-align: center;
      margin-bottom: 6px;
    }
    .timeline-filter {
      font-size: 11px;
      text-align: center;
      color: #0084ff;
      cursor: pointer;
      padding: 4px 0;
      border-radius: 4px;
    }
    .timeline-filter.active {
      background: #e3f2fd;
      font-weight: 600;
    }
    #timeline-bars {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 4px;
      overflow: auto;
    }
    .timeline-row {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .timeline-bar {
      height: 12px;
      border-radius: 4px;
      background: #cfd8dc;
      position: relative;
      cursor: pointer;
      flex: 1;
    }
    .timeline-bar span {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      border-radius: 4px;
      background: #42a5f5;
    }
    .timeline-bar.active {
      outline: 2px solid #0084ff;
    }
    .timeline-label {
      font-size: 10px;
      color: #666;
      text-transform: capitalize;
      letter-spacing: 0.2px;
      margin-top: 6px;
      cursor: pointer;
    }
    .timeline-label.active {
      color: #0084ff;
      font-weight: 600;
    }

    /* Chat container styling */
    #chat-container {
      padding: 10px;
      background-color: #ffffff;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
      overflow-y: auto;
      height: 80vh;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    #chat-container.hide-images img {
      display: none;
    }
    #chat-container.hide-images video {
      display: none;
    }
    #chat-container.hide-images .media-images-only {
      display: none;
    }
    #chat-container.hide-images .media-videos-only {
      display: none;
    }
    /* Chat bubble styling */
    .message {
      margin: 0;
      padding: 8px 12px;
      border-radius: 7px;
      max-width: 72%;
      word-wrap: break-word;
      clear: both;
    }
    .message.media-only {
      padding-top: 6px;
    }
    .message.media-only .media {
      margin-top: 0;
    }
    .message-row {
      display: flex;
      align-items: flex-start;
      gap: 8px;
      margin: 5px 0;
    }
    .message-row .message {
      display: inline-block;
    }
    .message-row.user {
      justify-content: flex-end;
    }
    .message-row.user .message {
      order: 1;
    }
    .message-row.user .initials {
      order: 2;
    }
    .message-row.other {
      justify-content: flex-start;
    }
    .message-row.other .initials {
      order: 1;
    }
    .message-row.other .message {
      order: 2;
    }
    .initials {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      flex-shrink: 0;
    }
    .message-row.media-only .initials {
    }
    .message-row.other .initials {
      background: #1976d2;
      color: #ffffff;
    }
    .message-row.user .initials {
      background: #0084ff;
      color: #ffffff;
    }
    .message.user {
      background-color: #e3f2fd;
      text-align: right;
    }
    .message.other {
      background-color: #ffffff;
      border: 1px solid #e9edef;
      text-align: left;
    }
    .time-group {
      padding: 6px 8px;
      border-radius: 6px;
      margin-top: 6px;
    }
    .time-group.day {
      background: #f7f8fa;
    }
    .time-group.night {
      background: #f0f2f5;
    }
    .time-header {
      font-size: 12px;
      color: #555;
      text-align: center;
      margin: 2px 0 6px;
      text-transform: capitalize;
    }
    img, video {
      max-width: 100%;
      margin-top: 5px;
      border-radius: 5px;
    }
    .media {
      margin-left: 20px;
      margin-top: 6px;
      opacity: 0.95;
    }
    .media img,
    .media video {
      margin-top: 0;
    }
    .media img {
      width: 100%;
      max-width: var(--image-size);
    }
    .image-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
      margin-top: 6px;
    }
    .image-grid img {
      width: 100%;
      height: auto;
      display: block;
    }
    .message-text {
      margin-top: 0;
      white-space: pre-wrap;
    }
    a.download-link {
      margin-top: 5px;
      display: block;
    }
    #media-controls {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin: 6px auto 12px;
      flex-wrap: wrap;
    }
    .control-button {
      border: 1px solid #d1d7db;
      background: #ffffff;
      color: #0084ff;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }
    .control-button.active {
      background: #0084ff;
      color: #ffffff;
      border-color: #0084ff;
    }
    #image-size-control {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #555;
      border: 1px solid #cfd8dc;
      background: #ffffff;
      padding: 6px 10px;
      border-radius: 6px;
    }
    #image-size {
      width: 140px;
    }
    #user-selector {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: #555;
      border: 1px solid #cfd8dc;
      background: #ffffff;
      padding: 6px 10px;
      border-radius: 6px;
    }
    #user-select {
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid #cfd8dc;
      background: #ffffff;
      font-size: 12px;
    }
    #load-controls {
      display: flex;
      justify-content: center;
      gap: 8px;
      align-items: center;
      margin: 0 auto 12px;
      flex-wrap: wrap;
      font-size: 12px;
      color: #666;
    }
    #load-hint {
      max-width: 640px;
      text-align: center;
    }
    #pick-folder {
      display: inline-flex;
    }
    #print-header,
    #print-footer {
      display: none;
    }
    @media print {
      body {
        background: #ffffff;
        padding: 0;
      }
      h2,
      #media-controls,
      #load-controls,
      #folderInput {
        display: none !important;
      }
      #app {
        max-width: none;
        margin: 0;
        padding: 0;
        grid-template-columns: 1fr;
      }
      #timeline {
        display: none !important;
      }
      #print-header,
      #print-footer {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
        font-size: 11px;
        color: #444;
      }
      #print-header {
        position: running(print-header);
        padding-bottom: 2mm;
        border-bottom: 1px solid #d1d7db;
      }
      #print-footer {
        position: running(print-footer);
        padding-top: 2mm;
        border-top: 1px solid #d1d7db;
      }

      #chat-container {
        height: auto !important;
        overflow: visible !important;
        box-shadow: none;
        border-radius: 0;
      }
      .message {
        max-width: 100%;
      }
      .message-row {
        margin: 2mm 0;
        break-inside: avoid;
        page-break-inside: avoid;
        -webkit-column-break-inside: avoid;
      }
      .time-group {
        break-inside: auto;
        page-break-inside: auto;
      }
      .time-header {
        break-after: avoid;
        page-break-after: avoid;
        orphans: 2;
      }
      .message-text {
        orphans: 3;
        widows: 3;
      }
      .media img {
        max-width: 60mm !important;
        height: auto;
      }
      .image-grid {
        grid-template-columns: repeat(2, minmax(0, 40mm));
        gap: 3mm;
      }
      .message.user {
        background-color: #bbdefb;
        border: 1px solid #90caf9;
      }
      .message.other {
        border: 1px solid #bdbdbd;
      }
      @page {
        size: A4;
        margin: 20mm 12mm 18mm;
        @top-left {
          content: element(print-header);
        }
        @bottom-left {
          content: element(print-footer);
        }
        @bottom-right {
          content: "Page " counter(page) " / " counter(pages);
        }
      }
    }
  </style>
</head>
<body>
  <h2>WhatsApp Chat Viewer</h2>
  <div id="print-header" aria-hidden="true">
    <span id="print-title">WhatsApp Chat Viewer</span>
  </div>
  <input type="file" id="folderInput" webkitdirectory multiple>
  <div id="media-controls">
    <button id="show-images" class="control-button active" type="button">Afficher images</button>
    <button id="hide-images" class="control-button" type="button">Masquer images</button>
    <label id="image-size-control" for="image-size">
      <span>Largeur images</span>
      <input id="image-size" type="range" min="80" max="480" step="10" value="120">
      <span id="image-size-value">120px</span>
    </label>
    <label id="user-selector" for="user-select">
      <span>Utilisateur (à droite):</span>
      <select id="user-select">
        <option value="">Chargez un fichier...</option>
      </select>
    </label>
  </div>
  <div id="load-controls">
    <button id="pick-folder" class="control-button" type="button">Choisir dossier (chat + médias)</button>
    <span id="load-hint">Choisissez le dossier qui contient <strong>_chat.txt</strong> et les médias. Le navigateur bloque souvent l'accès automatique aux fichiers locaux.</span>
  </div>
  <div id="app">
    <div id="timeline">
      <div id="timeline-title">Frise</div>
      <div id="timeline-bars"></div>
    </div>
    <div id="chat-container"></div>
  </div>
  <div id="print-footer" aria-hidden="true">
    <span id="print-pages"></span>
  </div>
  
  <script>
    // Global variables for infinite scroll loading
    let allMessages = [];
    let renderItems = [];
    let currentIndex = 0;
    const chunkSize = 100;
    const chatContainer = document.getElementById("chat-container");
    const timelineBars = document.getElementById("timeline-bars");
    const timelineTitle = document.getElementById("timeline-title");
    const showImagesButton = document.getElementById("show-images");
    const hideImagesButton = document.getElementById("hide-images");
    const imageSizeInput = document.getElementById("image-size");
    const imageSizeValue = document.getElementById("image-size-value");
    const userSelect = document.getElementById("user-select");
    const folderInput = document.getElementById("folderInput");
    const loadControls = document.getElementById("load-controls");
    const pickFolderButton = document.getElementById("pick-folder");
    const printTitle = document.getElementById("print-title");
    if (folderInput) {
      folderInput.style.display = "none";
    }
    if (loadControls) {
      loadControls.style.display = "flex";
    }
    if (printTitle) {
      const heading = document.querySelector("h2");
      printTitle.textContent = heading ? heading.textContent : document.title;
    }

    let activeDayKey = null; // null = all
    let activeMonthKey = null; // "YYYY-MM"
    let activeYearKey = null; // "YYYY"
    let lastGroupElement = null;
    let selectedUser = null; // The user whose messages appear on the right
    let dateOrder = "DMY"; // "DMY" or "MDY"

    const IMAGE_EXTS = ["jpg", "png", "jpeg", "gif", "webp"];
    const VIDEO_EXTS = ["mp4", "webm", "ogg"];

    const mediaFilesByNameLower = new Map(); // name -> File
    const mediaObjectUrlCache = new Map(); // name -> object URL

    function clearMediaCache() {
      for (const url of mediaObjectUrlCache.values()) {
        try { URL.revokeObjectURL(url); } catch {}
      }
      mediaObjectUrlCache.clear();
    }

    function getMediaObjectUrl(name) {
      const key = normalizeMediaName(name).toLowerCase();
      if (!key) return "";
      const cached = mediaObjectUrlCache.get(key);
      if (cached) return cached;
      const file = mediaFilesByNameLower.get(key);
      if (!file) return "";
      const url = URL.createObjectURL(file);
      mediaObjectUrlCache.set(key, url);
      return url;
    }

    function normalizeMediaName(name) {
      return (name || "")
        .toString()
        .replace(/\u200E/g, "")
        .trim();
    }

    let chatBaseDir = "";

    function getBaseDir() {
      const href = window.location.href;
      return href.endsWith("/") ? href : href.slice(0, href.lastIndexOf("/") + 1);
    }

    function getMediaBaseDir() {
      return chatBaseDir || getBaseDir();
    }

    function setChatBaseDirFromUrl(url) {
      try {
        const base = new URL(".", url).toString();
        chatBaseDir = base;
      } catch {
        chatBaseDir = "";
      }
    }

    function buildMediaUrl(name) {
      const normalized = normalizeMediaName(name);
      if (!normalized) return "";
      const lower = normalized.toLowerCase();
      if (
        lower.startsWith("http://") ||
        lower.startsWith("https://") ||
        lower.startsWith("file://") ||
        lower.startsWith("blob:")
      ) {
        return normalized;
      }
      const rel = normalized.replace(/\\/g, "/").replace(/^\/+/, "");
      const encoded = rel.split("/").map(encodeURIComponent).join("/");
      return new URL(encoded, getMediaBaseDir()).toString();
    }

    function applyResolvedMediaUrl(mediaElement, name) {
      const url = getMediaObjectUrl(name) || buildMediaUrl(name);
      if (!url) return;

      if (mediaElement.tagName === "A") {
        mediaElement.href = url;
      } else {
        mediaElement.src = url;
      }
    }

    function resolveMediaIntoElement(mediaElement, name) {
      const normalized = normalizeMediaName(name);
      if (!normalized) return;
      applyResolvedMediaUrl(mediaElement, normalized);
    }

    const PERIODS = [
      { name: "nuit", start: 22, end: 24, theme: "night" },
      { name: "nuit", start: 0, end: 5, theme: "night" },
      { name: "matin", start: 5, end: 12, theme: "day" },
      { name: "après-midi", start: 12, end: 17, theme: "day" },
      { name: "soir", start: 17, end: 22, theme: "night" }
    ];

    function parseTime(timeStr) {
      const trimmed = timeStr.trim();
      const ampmMatch = trimmed.match(/^(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(AM|PM)$/i);
      if (ampmMatch) {
        let hour = Number(ampmMatch[1]);
        const minute = Number(ampmMatch[2]);
        const second = Number(ampmMatch[3] || 0);
        const meridiem = ampmMatch[4].toUpperCase();
        if (meridiem === "PM" && hour < 12) hour += 12;
        if (meridiem === "AM" && hour === 12) hour = 0;
        return { hour, minute, second };
      }
      const [hh, min, ss] = trimmed.split(":").map(Number);
      return { hour: hh, minute: min, second: ss || 0 };
    }

    function parseDate(dateStr, timeStr) {
      const [partA, partB, partC] = dateStr.split("/").map(Number);
      let year = partC;
      if (year < 100) {
        year = year >= 70 ? 1900 + year : 2000 + year;
      }
      let day = partA;
      let month = partB;
      if (dateOrder === "MDY") {
        day = partB;
        month = partA;
      }
      if (month < 1 || month > 12) {
        day = partA;
        month = partB;
      }
      const { hour, minute, second } = parseTime(timeStr);
      return new Date(year, month - 1, day, hour, minute, second);
    }

    function detectDateOrder(messages, preferMDY) {
      let dmyHits = 0;
      let mdyHits = 0;
      messages.forEach(msg => {
        const [partA, partB] = msg.date.split("/").map(Number);
        if (Number.isNaN(partA) || Number.isNaN(partB)) return;
        if (partA > 12 && partB <= 12) {
          dmyHits += 1;
        } else if (partB > 12 && partA <= 12) {
          mdyHits += 1;
        }
      });
      if (mdyHits > dmyHits) return "MDY";
      if (dmyHits > mdyHits) return "DMY";
      return preferMDY ? "MDY" : "DMY";
    }

    function getPeriod(dateObj) {
      const hour = dateObj.getHours();
      for (const p of PERIODS) {
        if (hour >= p.start && hour < p.end) {
          return p;
        }
      }
      return PERIODS[2];
    }

    function formatDateFr(dateObj) {
      return dateObj.toLocaleDateString("fr-FR", {
        weekday: "long",
        day: "numeric",
        month: "long",
        year: "numeric"
      });
    }
    function parseMessageContent(message) {
      const cleanedMessage = message.replace(/\u200E/g, "").trim();
      const attachmentRegex = /<\s*(?:pi(?:e|\u00e8|\u00c3\u00a8)ce jointe|fichier joint|attached)\s*:\s*([^>]+)\s*>/ig;
      const fileAttachedText = "(file attached)";
      let fileNames = [];
      let textOnly = cleanedMessage;

      const attachmentMatches = [...cleanedMessage.matchAll(attachmentRegex)];
      if (attachmentMatches.length > 0) {
        fileNames = attachmentMatches.map(match => match[1].trim()).filter(Boolean);
        attachmentRegex.lastIndex = 0;
        textOnly = cleanedMessage.replace(attachmentRegex, "").trim();
      } else if (cleanedMessage.includes(fileAttachedText)) {
        const inferred = cleanedMessage.replace(fileAttachedText, "").trim();
        if (inferred) {
          fileNames = [inferred];
        }
        textOnly = "";
      }

      return { textOnly, fileNames };
    }

    function splitUrlToken(token) {
      const match = token.match(/^(https?:\/\/[^\s<>"']+?)([).,!?:;]+)?$/i);
      if (!match) return [token, ""];
      return [match[1], match[2] || ""];
    }

    function linkifyText(text) {
      const fragment = document.createDocumentFragment();
      const urlRegex = /(https?:\/\/[^\s<>"']+)/ig;
      let lastIndex = 0;
      let match;

      while ((match = urlRegex.exec(text)) !== null) {
        const before = text.slice(lastIndex, match.index);
        if (before) {
          fragment.appendChild(document.createTextNode(before));
        }

        const [urlPart, trailing] = splitUrlToken(match[0]);
        const anchor = document.createElement("a");
        anchor.href = urlPart;
        let displayText = urlPart;
        try {
          const parsed = new URL(urlPart);
          if (parsed.host) {
            displayText = parsed.host;
          }
        } catch {}
        anchor.textContent = displayText;
        anchor.target = "_blank";
        anchor.rel = "noopener noreferrer";
        fragment.appendChild(anchor);

        if (trailing) {
          fragment.appendChild(document.createTextNode(trailing));
        }

        lastIndex = match.index + match[0].length;
      }

      const remaining = text.slice(lastIndex);
      if (remaining) {
        fragment.appendChild(document.createTextNode(remaining));
      }
      return fragment;
    }

    function isImageFile(name) {
      const ext = name.split('.').pop().toLowerCase();
      return IMAGE_EXTS.includes(ext);
    }
    function isVideoFile(name) {
      const ext = name.split('.').pop().toLowerCase();
      return VIDEO_EXTS.includes(ext);
    }

    function getInitials(name) {
      const cleaned = (name || "").trim();
      if (!cleaned) return "?";
      const parts = cleaned.split(/\s+/).filter(Boolean);
      const first = parts[0]?.charAt(0) || "";
      const last = parts.length > 1 ? parts[parts.length - 1].charAt(0) : "";
      return (first + last).toUpperCase();
    }
    function mergeImageSequences(messages) {
      const merged = [];
      for (let i = 0; i < messages.length; i++) {
        const msg = messages[i];
        const { textOnly, fileNames } = parseMessageContent(msg.message);
        const isImageOnly = textOnly === "" && fileNames.length > 0 && fileNames.every(isImageFile);
        if (!isImageOnly) {
          merged.push(msg);
          continue;
        }

        const groupedFileNames = [...fileNames];
        let j = i + 1;
        for (; j < messages.length; j++) {
          const next = messages[j];
          if (next.sender !== msg.sender) break;
          const nextContent = parseMessageContent(next.message);
          const nextIsImageOnly = nextContent.textOnly === "" && nextContent.fileNames.length > 0 && nextContent.fileNames.every(isImageFile);
          if (!nextIsImageOnly) break;
          groupedFileNames.push(...nextContent.fileNames);
        }

        const groupedMessage = groupedFileNames.map(name => `< piece jointe : ${name} >`).join(" ");
        merged.push({ ...msg, message: groupedMessage });
        i = j - 1;
      }
      return merged;
    }

    function setImagesVisible(visible) {
      chatContainer.classList.toggle("hide-images", !visible);
      showImagesButton.classList.toggle("active", visible);
      hideImagesButton.classList.toggle("active", !visible);
    }

    showImagesButton.addEventListener("click", () => setImagesVisible(true));
    hideImagesButton.addEventListener("click", () => setImagesVisible(false));
    
    function setImageSize(value) {
      const pxValue = `${value}px`;
      document.documentElement.style.setProperty("--image-size", pxValue);
      imageSizeValue.textContent = pxValue;
    }
    setImageSize(imageSizeInput.value);
    imageSizeInput.addEventListener("input", (event) => setImageSize(event.target.value));

    // User selection handler
    userSelect.addEventListener("change", (event) => {
      selectedUser = event.target.value;
      // Re-render with new user selection
      if (activeDayKey) {
        renderFromFilter(activeDayKey);
      } else if (activeMonthKey) {
        renderFromMonth(activeMonthKey);
      } else if (activeYearKey) {
        renderFromYear(activeYearKey);
      } else {
        renderFromFilter(null);
      }
    });

    // Function to create a chat bubble element
    function createMessageElement(date, time, sender, message, isUser) {
      const row = document.createElement("div");
      row.classList.add("message-row", isUser ? "user" : "other");

      const initials = document.createElement("div");
      initials.classList.add("initials");
      initials.textContent = getInitials(sender);
      
      let msgElement = document.createElement("div");
      msgElement.classList.add("message", isUser ? "user" : "other");

      const { textOnly, fileNames } = parseMessageContent(message);

      const hasText = Boolean(textOnly);
      const hasMedia = fileNames.length > 0;
      const isMediaOnly = !hasText && hasMedia;
      if (isMediaOnly) {
        row.classList.add("media-only");
        msgElement.classList.add("media-only");
      }

      if (hasText) {
        const textEl = document.createElement("div");
        textEl.classList.add("message-text");
        textEl.appendChild(linkifyText(textOnly));
        msgElement.appendChild(textEl);
      }

      if (hasMedia) {
        const mediaWrap = document.createElement("div");
        mediaWrap.classList.add("media");

        const allImages = fileNames.every(isImageFile);
        const allVideos = fileNames.every(isVideoFile);
        if (allImages) {
          mediaWrap.classList.add("media-images-only");
        }
        if (allVideos) {
          mediaWrap.classList.add("media-videos-only");
        }

        if (fileNames.length > 1 && allImages) {
          const grid = document.createElement("div");
          grid.classList.add("image-grid");
          fileNames.forEach(name => {
            const img = document.createElement("img");
            img.loading = "lazy";
            resolveMediaIntoElement(img, name);
            grid.appendChild(img);
          });
          mediaWrap.appendChild(grid);
        } else {
          fileNames.forEach(name => {
            const fileExt = name.split('.').pop().toLowerCase();
            let mediaElement;
            if (IMAGE_EXTS.includes(fileExt)) {
              mediaElement = document.createElement("img");
              mediaElement.loading = "lazy";
              resolveMediaIntoElement(mediaElement, name);
            } else if (VIDEO_EXTS.includes(fileExt)) {
              mediaElement = document.createElement("video");
              mediaElement.controls = true;
              resolveMediaIntoElement(mediaElement, name);
            } else {
              mediaElement = document.createElement("a");
              mediaElement.innerText = `Télécharger: ${name}`;
              mediaElement.classList.add("download-link");
              mediaElement.target = "_blank";
              resolveMediaIntoElement(mediaElement, name);
            }
            mediaWrap.appendChild(mediaElement);
          });
        }
        msgElement.appendChild(mediaWrap);
      }
      
      // Append in correct order for grid
      row.appendChild(initials);
      row.appendChild(msgElement);
      
      return row;
    }

    function createHeaderElement(dateObj, period) {
      const group = document.createElement("div");
      group.classList.add("time-group", period.theme);
      const header = document.createElement("div");
      header.classList.add("time-header");
      header.textContent = `${formatDateFr(dateObj)} — ${period.name}`;
      group.appendChild(header);
      return group;
    }

    function buildRenderItems(messages) {
      const items = [];
      let lastKey = "";
      
      messages.forEach(msg => {
        const dateObj = parseDate(msg.date, msg.time);
        const period = getPeriod(dateObj);
        const dayKey = dateObj.toISOString().slice(0, 10);
        
        // Determine if this message is from the selected user
        const isUser = selectedUser ? (msg.sender === selectedUser) : false;
        
        const key = `${dayKey}-${period.name}`;
        if (key !== lastKey) {
          items.push({
            type: "header",
            dateObj,
            period
          });
          lastKey = key;
        }
        items.push({
          type: "message",
          data: msg,
          isUser
        });
      });
      return items;
    }

    function renderFromFilter(dayKey) {
      activeDayKey = dayKey;
      activeMonthKey = null;
      activeYearKey = null;
      const filteredRaw = dayKey
        ? allMessages.filter(m => parseDate(m.date, m.time).toISOString().slice(0, 10) === dayKey)
        : allMessages.slice();
      const filtered = mergeImageSequences(filteredRaw);
      renderItems = buildRenderItems(filtered);
      chatContainer.innerHTML = "";
      currentIndex = 0;
      lastGroupElement = null;
      loadNextMessages();
      updateTimelineActive();
    }

    function renderFromMonth(monthKey) {
      activeDayKey = null;
      activeMonthKey = monthKey;
      activeYearKey = null;
      const filteredRaw = allMessages.filter(m => {
        const key = parseDate(m.date, m.time).toISOString().slice(0, 7);
        return key === monthKey;
      });
      const filtered = mergeImageSequences(filteredRaw);
      renderItems = buildRenderItems(filtered);
      chatContainer.innerHTML = "";
      currentIndex = 0;
      lastGroupElement = null;
      loadNextMessages();
      updateTimelineActive();
    }

    function renderFromYear(yearKey) {
      activeDayKey = null;
      activeMonthKey = null;
      activeYearKey = yearKey;
      const filteredRaw = allMessages.filter(m => {
        const key = parseDate(m.date, m.time).getFullYear().toString();
        return key === yearKey;
      });
      const filtered = mergeImageSequences(filteredRaw);
      renderItems = buildRenderItems(filtered);
      chatContainer.innerHTML = "";
      currentIndex = 0;
      lastGroupElement = null;
      loadNextMessages();
      updateTimelineActive();
    }

    function updateTimelineActive() {
      const bars = timelineBars.querySelectorAll(".timeline-bar");
      bars.forEach(bar => {
        const key = bar.getAttribute("data-day");
        bar.classList.toggle("active", key === activeDayKey);
      });
      const labels = timelineBars.querySelectorAll(".timeline-label");
      labels.forEach(label => {
        const monthKey = label.getAttribute("data-month");
        const yearKey = label.getAttribute("data-year");
        label.classList.toggle("active", monthKey === activeMonthKey || yearKey === activeYearKey);
      });
      const allFilter = document.getElementById("timeline-all");
      if (allFilter) {
        allFilter.classList.toggle("active", activeDayKey === null && activeMonthKey === null && activeYearKey === null);
      }
    }

    function buildTimeline(messages) {
      timelineBars.innerHTML = "";
      const counts = new Map();
      messages.forEach(msg => {
        const dateObj = parseDate(msg.date, msg.time);
        const dayKey = dateObj.toISOString().slice(0, 10);
        counts.set(dayKey, (counts.get(dayKey) || 0) + 1);
      });
      const entries = Array.from(counts.entries()).sort((a, b) => a[0].localeCompare(b[0]));
      const maxCount = Math.max(1, ...entries.map(e => e[1]));

      // Add "All" filter
      const allFilter = document.createElement("div");
      allFilter.id = "timeline-all";
      allFilter.classList.add("timeline-filter");
      allFilter.textContent = "Toute la période";
      allFilter.addEventListener("click", () => renderFromFilter(null));
      timelineBars.appendChild(allFilter);

      let lastMonthKey = "";
      let lastYearKey = "";
      entries.forEach(([dayKey, count]) => {
        const [year, month] = dayKey.split("-");
        const monthKey = `${year}-${month}`;
        if (year !== lastYearKey) {
          const yearLabel = document.createElement("div");
          yearLabel.classList.add("timeline-label");
          yearLabel.textContent = year;
          yearLabel.setAttribute("data-year", year);
          timelineBars.appendChild(yearLabel);
          lastYearKey = year;
          lastMonthKey = "";
        }
        if (monthKey !== lastMonthKey) {
          const dateObj = new Date(Number(year), Number(month) - 1, 1);
          const monthLabel = document.createElement("div");
          monthLabel.classList.add("timeline-label");
          monthLabel.textContent = dateObj.toLocaleDateString("fr-FR", { month: "long" });
          monthLabel.setAttribute("data-month", monthKey);
          timelineBars.appendChild(monthLabel);
          lastMonthKey = monthKey;
        }
        const row = document.createElement("div");
        row.classList.add("timeline-row");
        const bar = document.createElement("div");
        bar.classList.add("timeline-bar");
        bar.setAttribute("data-day", dayKey);
        const fill = document.createElement("span");
        const ratio = count / maxCount;
        const scaledRatio = Math.sqrt(ratio);
        const widthPercent = Math.max(12, Math.round(scaledRatio * 100));
        fill.style.width = `${widthPercent}%`;
        fill.style.background = `rgba(76, 175, 80, ${0.35 + scaledRatio * 0.65})`;
        bar.title = `${dayKey} — ${count} messages`;
        bar.appendChild(fill);
        bar.addEventListener("click", () => renderFromFilter(dayKey));
        row.appendChild(bar);
        timelineBars.appendChild(row);
      });
      updateTimelineActive();
    }

    // Event delegation for reliability
    timelineBars.addEventListener("click", (event) => {
      const bar = event.target.closest(".timeline-bar");
      if (bar && bar.getAttribute("data-day")) {
        renderFromFilter(bar.getAttribute("data-day"));
        return;
      }
      const monthLabel = event.target.closest(".timeline-label[data-month]");
      if (monthLabel) {
        renderFromMonth(monthLabel.getAttribute("data-month"));
        return;
      }
      const yearLabel = event.target.closest(".timeline-label[data-year]");
      if (yearLabel) {
        renderFromYear(yearLabel.getAttribute("data-year"));
        return;
      }
      const allFilter = event.target.closest("#timeline-all");
      if (allFilter) {
        renderFromFilter(null);
      }
    });

    // Function to load the next batch of messages
    function loadNextMessages() {
      let endIndex = Math.min(currentIndex + chunkSize, renderItems.length);
      let currentGroup = lastGroupElement;
      for (let i = currentIndex; i < endIndex; i++) {
        const item = renderItems[i];
        if (item.type === "header") {
          currentGroup = createHeaderElement(item.dateObj, item.period);
          chatContainer.appendChild(currentGroup);
          lastGroupElement = currentGroup;
        } else {
          const { date, time, sender, message } = item.data;
          const msgElement = createMessageElement(date, time, sender, message, item.isUser);
          if (currentGroup) {
            currentGroup.appendChild(msgElement);
          } else {
            chatContainer.appendChild(msgElement);
          }
        }
      }
      currentIndex = endIndex;
    }

    function loadAllMessagesForPrint() {
      if (!renderItems.length) return;
      while (currentIndex < renderItems.length) {
        loadNextMessages();
      }
    }

    // Event listener for infinite scroll: load more messages when near the bottom
    chatContainer.addEventListener("scroll", function() {
      if (chatContainer.scrollTop + chatContainer.clientHeight >= chatContainer.scrollHeight - 50) {
        if (currentIndex < allMessages.length) {
          loadNextMessages();
        }
      }
    });

    window.addEventListener("beforeprint", loadAllMessagesForPrint);
    const printMedia = window.matchMedia ? window.matchMedia("print") : null;
    if (printMedia && typeof printMedia.addEventListener === "function") {
      printMedia.addEventListener("change", (event) => {
        if (event.matches) {
          loadAllMessagesForPrint();
        }
      });
    } else if (printMedia && typeof printMedia.addListener === "function") {
      printMedia.addListener((event) => {
        if (event.matches) {
          loadAllMessagesForPrint();
        }
      });
    }

    // Populate user selector dropdown
    function populateUserSelector(messages) {
      const senders = new Set();
      messages.forEach(msg => senders.add(msg.sender));
      
      userSelect.innerHTML = "";
      
      // Add default option
      const defaultOption = document.createElement("option");
      defaultOption.value = "";
      defaultOption.textContent = "Sélectionner l'utilisateur...";
      userSelect.appendChild(defaultOption);
      
      // Add sender options
      Array.from(senders).sort().forEach(sender => {
        const option = document.createElement("option");
        option.value = sender;
        option.textContent = sender;
        userSelect.appendChild(option);
      });
      
      // Auto-select second sender if there are exactly 2 senders
      const sendersArray = Array.from(senders).sort();
      if (sendersArray.length === 2) {
        selectedUser = sendersArray[1];
        userSelect.value = selectedUser;
      }
    }

    function loadChatFromText(rawText) {
      // Reset chat container and global message variables
      chatContainer.innerHTML = "";
      allMessages = [];
      renderItems = [];
      currentIndex = 0;
      activeDayKey = null;
      activeMonthKey = null;
      activeYearKey = null;
      lastGroupElement = null;
      selectedUser = null;

      // Regex to match:
      // - [DD/MM/YYYY HH:MM:SS] Sender: Message
      // - [MM/DD/YY, H:MM:SS AM] Sender: Message
      const lineRegexClassic = /^\[(\d{2}\/\d{2}\/\d{4})\s+(\d{2}:\d{2}:\d{2})\]\s*(.*?):\s*(.*)$/;
      const lineRegexEnglish = /^\[(\d{1,2}\/\d{1,2}\/\d{2,4}),\s+(\d{1,2}:\d{2}(?::\d{2})?\s*(?:AM|PM))\]\s*-?\s*(.*?):\s*(.*)$/i;
      const lines = rawText.split(/\r?\n/);

      let current = null;
      let preferMDY = false;
      lines.forEach(rawLine => {
        const line = rawLine.replace(/\u200E/g, "").replace(/^\uFEFF/, "");
        let match = line.match(lineRegexClassic);
        let isEnglish = false;
        if (!match) {
          match = line.match(lineRegexEnglish);
          isEnglish = Boolean(match);
        }
        if (match) {
          if (current) {
            allMessages.push(current);
          }
          const [_, date, time, sender, message] = match;
          if (isEnglish) {
            preferMDY = true;
          }
          current = { date, time, sender, message };
        } else if (current) {
          current.message += "\n" + line;
        }
      });
      if (current) {
        allMessages.push(current);
      }

      dateOrder = detectDateOrder(allMessages, preferMDY);
      populateUserSelector(allMessages);
      buildTimeline(allMessages);
      renderFromFilter(null);
      if (loadControls) {
        loadControls.style.display = "flex";
      }
    }

    function showLoadFailure(error) {
      console.error("Auto-load _chat.txt failed:", error);
      chatContainer.innerHTML =
        "<p style=\"padding:12px;color:#666;\">Impossible de charger automatiquement <strong>_chat.txt</strong>. " +
        "Choisissez le dossier contenant <strong>_chat.txt</strong> et les médias.</p>";
      if (loadControls) {
        loadControls.style.display = "flex";
      }
      if (pickFolderButton) {
        pickFolderButton.style.display = "inline-flex";
      }
    }

    async function loadChatFromFolderFiles(files) {
      clearMediaCache();
      mediaFilesByNameLower.clear();
      const fileList = Array.from(files || []);
      fileList.forEach(file => {
        const key = (file.name || "").toLowerCase();
        if (key && !mediaFilesByNameLower.has(key)) {
          mediaFilesByNameLower.set(key, file);
        }
      });

      const chatFile =
        mediaFilesByNameLower.get("_chat_corrected.txt") ||
        mediaFilesByNameLower.get("_chat.txt");
      if (!chatFile) {
        throw new Error("Folder selection does not include _chat.txt");
      }

      const text = await chatFile.text();
      if (!text.trim()) {
        throw new Error("Empty chat file");
      }
      chatBaseDir = "";
      loadChatFromText(text);
    }

    async function autoLoadChatFile() {
      const candidates = ["_chat_corrected.txt", "_chat.txt"];
      try {
        const baseHref = window.location.href;
        const baseDir = baseHref.endsWith("/") ? baseHref : baseHref.slice(0, baseHref.lastIndexOf("/") + 1);
        let text = "";
        for (const name of candidates) {
          const chatUrl = new URL(name, baseDir);
          const response = await fetch(chatUrl.toString(), { cache: "no-store" });
          if (!response.ok) continue;
          text = await response.text();
          if (text.trim()) {
            setChatBaseDirFromUrl(chatUrl.toString());
            break;
          }
        }
        if (!text.trim()) {
          throw new Error("Empty or missing chat file");
        }
        loadChatFromText(text);
      } catch (error) {
        showLoadFailure(error);
      }
    }

    if (folderInput) {
      folderInput.addEventListener("change", async function(event) {
        const files = event.target.files;
        if (!files || !files.length) return;
        try {
          await loadChatFromFolderFiles(files);
        } catch (error) {
          console.error("Folder load failed:", error);
          showLoadFailure(error);
        }
      });
    }

    if (pickFolderButton) {
      pickFolderButton.addEventListener("click", function() {
        if (folderInput) {
          folderInput.click();
        }
      });
    }

    // Auto-load _chat.txt from the same folder
    autoLoadChatFile();
  </script>
</body>
</html>
